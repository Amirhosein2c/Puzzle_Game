<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>ARGOMAN Puzzle</title>
    <style>
      body {
        margin: 0;
        background: #f75f45;
        color: #707070;
        height: 100vh;
        overflow: hidden;
        font-family: Arial, sans-serif;
        user-select: none;
      }

      #hud {
        position: fixed;
        top: 16px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 24px;
        z-index: 1000;
      }

      #board {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background: #ffffff;
        /* border: 1px solid rgba(255, 255, 255, 0.15); */
        touch-action: none;
      }

      .tile {
        position: absolute;
        background-repeat: no-repeat;
        border: 1px solid rgba(255, 255, 255, 0.15);
        box-sizing: border-box;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
        cursor: grab;
        transition: left 1s cubic-bezier(0.22, 0.61, 0.36, 1),
          top 1s cubic-bezier(0.22, 0.61, 0.36, 1), box-shadow 1s ease;
      }

      .tile.dragging {
        transition: none;
        cursor: grabbing;
        z-index: 1000 !important;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
      }

      .tile.locked {
        border: none;
        cursor: default;
        box-shadow: none;
      }

      #message {
        position: fixed;
        bottom: 32px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 128px;
        color: #f75f45;
        opacity: 0;
        transition: opacity 1s ease;
      }

      #message.show {
        opacity: 1;
      }

      #sideControls {
        position: fixed;
        right: 24px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 1000;
      }

      #sideControls button {
        background: #222;
        color: #eee;
        border: 1px solid #444;
        padding: 10px 14px;
        font-size: 14px;
        cursor: pointer;
      }

      #sideControls button.active {
        background: #4caf50;
        color: #000;
        border-color: #4caf50;
      }

      #sideControls button:hover {
        background: #333;
      }

      #startOverlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #ffffff;
        z-index: 9999;
        cursor: pointer;
      }

      #startOverlay.hidden {
        display: none;
      }

      .startText {
        color: #f75f45;
        font-size: clamp(24px, 5vw, 48px);
        letter-spacing: 0.1em;
      }
    </style>
  </head>
  <body>
    <div id="startOverlay">
      <div class="startText">Tap to Begin</div>
    </div>

    <div id="hud">
      <div>Time: <span id="time">0.0</span>s</div>
      <div>Moves: <span id="moves">0</span></div>
    </div>

    <div id="sideControls">
      <button id="resetBtn">Reset</button>
      <button id="pauseBtn">Pause</button>
      <button data-size="2">2x2</button>
      <button data-size="3" class="active">3×3</button>
      <button data-size="4">4×4</button>
    </div>

    <div id="board"></div>
    <div id="message">You win!</div>

    <audio id="swapSound"></audio>
    <audio id="winSound"></audio>

    <script>
      /* ================= STATE ================= */
      const board = document.getElementById("board");
      const startOverlay = document.getElementById("startOverlay");
      const timeEl = document.getElementById("time");
      const movesEl = document.getElementById("moves");
      const message = document.getElementById("message");
      const swapSound = document.getElementById("swapSound");
      const winSound = document.getElementById("winSound");
      const resetBtn = document.getElementById("resetBtn");
      const pauseBtn = document.getElementById("pauseBtn");
      const sizeButtons = document.querySelectorAll(
        "#sideControls button[data-size]"
      );

      let SIZE = 3;
      let tiles = [];
      const currentImage = "./Argoman_Logo.png";
      let paused = false;
      let moves = 0;
      let startTime = 0;
      let timer = null;
      let zCounter = 1;
      let allowExit = false;

      /* ================= FULLSCREEN START ================= */
      startOverlay.addEventListener(
        "pointerdown",
        async () => {
          startOverlay.classList.add("hidden");
          if (!document.fullscreenElement) {
            try {
              await document.documentElement.requestFullscreen();
            } catch (e) {}
          }
        },
        { once: true }
      );

      /* ================= GAME ================= */
      function startGame() {
        clearInterval(timer);
        board.innerHTML = "";
        tiles = [];
        moves = 0;
        zCounter = 1;
        paused = false;
        pauseBtn.textContent = "Pause";
        movesEl.textContent = "0";
        message.classList.remove("show");

        const boardSize = Math.min(window.innerWidth, window.innerHeight) * 0.9;
        const tileSize = boardSize / SIZE;

        board.style.width = boardSize + "px";
        board.style.height = boardSize + "px";

        for (let i = 0; i < SIZE * SIZE; i++) {
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.dataset.correct = i;
          tile.dataset.locked = "false";

          const col = i % SIZE;
          const row = Math.floor(i / SIZE);

          tile.style.width = tileSize + "px";
          tile.style.height = tileSize + "px";
          tile.style.left = col * tileSize + "px";
          tile.style.top = row * tileSize + "px";
          tile.style.backgroundImage = `url(${currentImage})`;
          tile.style.backgroundSize = `${boardSize}px ${boardSize}px`;
          tile.style.backgroundPosition = `-${col * tileSize}px -${
            row * tileSize
          }px`;

          enablePaperPhysics(tile, tileSize);
          tiles.push(tile);
          board.appendChild(tile);
        }

        setTimeout(shuffleTiles, 5000);
        startTimer();
      }

      function shuffleTiles() {
        tiles.forEach((tile) => {
          tile.style.left =
            Math.random() * (board.clientWidth - tile.clientWidth) + "px";
          tile.style.top =
            Math.random() * (board.clientHeight - tile.clientHeight) + "px";
          tile.style.zIndex = zCounter++;
        });
      }

      function startTimer() {
        startTime = performance.now();
        timer = setInterval(() => {
          if (!paused) {
            timeEl.textContent = (
              (performance.now() - startTime) /
              1000
            ).toFixed(1);
          }
        }, 100);
      }

      /* ================= PAPER PHYSICS ================= */
      function enablePaperPhysics(tile, tileSize) {
        let offsetX = 0,
          offsetY = 0;

        tile.addEventListener("pointerdown", (e) => {
          if (paused || tile.dataset.locked === "true") return;
          tile.setPointerCapture(e.pointerId);
          tile.classList.add("dragging");
          tile.style.zIndex = zCounter++;
          offsetX = e.clientX - tile.offsetLeft;
          offsetY = e.clientY - tile.offsetTop;
        });

        tile.addEventListener("pointermove", (e) => {
          if (!tile.classList.contains("dragging")) return;
          tile.style.left = e.clientX - offsetX + "px";
          tile.style.top = e.clientY - offsetY + "px";
        });

        tile.addEventListener("pointerup", (e) => {
          if (!tile.classList.contains("dragging")) return;
          tile.releasePointerCapture(e.pointerId);
          tile.classList.remove("dragging");
          handleDrop(tile, tileSize);
        });
      }

      function handleDrop(tile, tileSize) {
        const rect = tile.getBoundingClientRect();
        const boardRect = board.getBoundingClientRect();
        const col = Math.round((rect.left - boardRect.left) / tileSize);
        const row = Math.round((rect.top - boardRect.top) / tileSize);
        const targetIndex = row * SIZE + col;

        moves++;
        movesEl.textContent = moves;

        if (targetIndex === +tile.dataset.correct) {
          tile.style.left = col * tileSize + "px";
          tile.style.top = row * tileSize + "px";
          tile.classList.add("locked");
          tile.dataset.locked = "true";
          tile.style.zIndex = 0;
        }

        if (tiles.every((t) => t.dataset.locked === "true")) finishGame();
      }

      function finishGame() {
        clearInterval(timer);
        paused = true;
        message.classList.add("show");
      }

      /* ================= UI ================= */
      resetBtn.addEventListener("click", startGame);

      pauseBtn.addEventListener("click", () => {
        paused = !paused;
        pauseBtn.textContent = paused ? "Resume" : "Pause";
        if (!paused)
          startTime = performance.now() - parseFloat(timeEl.textContent) * 1000;
      });

      sizeButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          SIZE = Number(btn.dataset.size);
          sizeButtons.forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          startGame();
        });
      });

      /* ================= FULLSCREEN LOCK ================= */
      document.addEventListener("touchstart", (e) => {
        if (e.touches.length >= 3) allowExit = true;
      });

      document.addEventListener("touchend", (e) => {
        if (e.touches.length === 0) allowExit = false;
      });

      document.addEventListener("fullscreenchange", () => {
        if (!document.fullscreenElement && !allowExit) {
          document.documentElement.requestFullscreen().catch(() => {});
        }
      });

      /* ================= START ================= */
      const img = new Image();
      img.onload = startGame;
      img.src = currentImage;
    </script>
  </body>
</html>
